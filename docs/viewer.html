<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SCRIPTA Docs Viewer</title>
  <style>
    :root {
      --ink: #1f2a30;
      --muted: #50616b;
      --paper: #fbf7ef;
      --accent: #1b6a73;
      --accent-2: #b85c38;
      --border: #d6cfc2;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      color: var(--ink);
      background: linear-gradient(180deg, #f7efe3 0%, #f3f7f6 100%);
      font-family: "Palatino Linotype", "Book Antiqua", Palatino, serif;
    }
    header {
      padding: 28px 20px 14px;
      border-bottom: 1px solid var(--border);
      background: rgba(255,255,255,0.75);
      backdrop-filter: blur(6px);
      position: sticky;
      top: 0;
      z-index: 10;
    }
    header h1 { margin: 0 0 6px; font-size: 26px; }
    header .meta { color: var(--muted); font-size: 14px; }
    main {
      max-width: 980px;
      margin: 0 auto;
      padding: 24px 20px 60px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 24px;
    }
    .toc {
      padding: 16px;
      background: #fffaf0;
      border: 1px solid var(--border);
      border-radius: 10px;
    }
    .doc {
      padding: 24px;
      background: #ffffff;
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.05);
    }
    .doc img { max-width: 100%; height: auto; }
    .doc pre {
      background: #f3f0e8;
      padding: 12px;
      border-radius: 8px;
      overflow-x: auto;
    }
    .doc code { font-family: "Courier New", Courier, monospace; }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
    .links { margin-top: 8px; font-size: 14px; }
    .links a { margin-right: 12px; }
    
    /* Table styles */
    .doc table {
      width: 100%;
      border-collapse: collapse;
      margin: 1em 0;
      font-size: 0.95em;
    }
    .doc th, .doc td {
      border: 1px solid var(--border);
      padding: 10px 12px;
      text-align: left;
      vertical-align: top;
    }
    .doc th {
      background: #f5f2ea;
      font-weight: 600;
      color: var(--ink);
    }
    .doc tr:nth-child(even) {
      background: #faf9f6;
    }
    .doc tr:hover {
      background: #f0efe8;
    }
    
    @media (min-width: 900px) {
      main { grid-template-columns: 280px 1fr; }
      .toc { position: sticky; top: 90px; align-self: start; }
    }
  </style>
</head>
<body>
  <header>
    <h1 id="doc-title">SCRIPTA Docs Viewer</h1>
    <div class="meta" id="doc-meta">Load a document with ?doc=specs/DS01-Vision.md</div>
  </header>

  <main>
    <aside class="toc" id="toc">
      <strong>Contents</strong>
      <div id="toc-list"></div>
      <div class="links" id="doc-links"></div>
    </aside>
    <article class="doc" id="content">Select a document.</article>
  </main>

  <script>
    const params = new URLSearchParams(window.location.search);
    const docParam = params.get('doc');
    const contentEl = document.getElementById('content');
    const tocListEl = document.getElementById('toc-list');
    const titleEl = document.getElementById('doc-title');
    const metaEl = document.getElementById('doc-meta');
    const linksEl = document.getElementById('doc-links');

    function escapeHtml(str) {
      return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function slugify(text) {
      return text
        .toLowerCase()
        .replace(/[^a-z0-9\s-]/g, '')
        .trim()
        .replace(/\s+/g, '-');
    }

    function resolveUrl(url, baseUrl) {
      if (/^(https?:|data:|mailto:|#)/.test(url)) return url;
      try {
        return new URL(url, baseUrl).href;
      } catch (e) {
        return url;
      }
    }

    function renderMarkdown(md, baseUrl) {
      const lines = md.replace(/\r\n/g, '\n').split('\n');
      let html = '';
      let inCode = false;
      let codeLang = '';
      let codeBuffer = [];
      let paraBuffer = [];
      let listBuffer = [];
      let tableBuffer = [];
      let inTable = false;
      const headings = [];

      function flushParagraph() {
        if (paraBuffer.length) {
          const text = paraBuffer.join(' ');
          html += `<p>${inline(text, baseUrl)}</p>`;
          paraBuffer = [];
        }
      }

      function flushList() {
        if (listBuffer.length) {
          html += '<ul>' + listBuffer.map(item => `<li>${inline(item, baseUrl)}</li>`).join('') + '</ul>';
          listBuffer = [];
        }
      }

      function flushCode() {
        if (codeBuffer.length) {
          const code = escapeHtml(codeBuffer.join('\n'));
          const langClass = codeLang ? ` class="language-${escapeHtml(codeLang)}"` : '';
          html += `<pre><code${langClass}>${code}</code></pre>`;
          codeBuffer = [];
          codeLang = '';
        }
      }

      function flushTable() {
        if (tableBuffer.length < 2) {
          tableBuffer = [];
          inTable = false;
          return;
        }
        
        // Parse header row
        const headerRow = tableBuffer[0];
        const headerCells = parseTableRow(headerRow);
        
        // Skip separator row (index 1)
        // Parse data rows (index 2+)
        const dataRows = tableBuffer.slice(2);
        
        let tableHtml = '<table><thead><tr>';
        for (const cell of headerCells) {
          tableHtml += `<th>${inline(cell.trim(), baseUrl)}</th>`;
        }
        tableHtml += '</tr></thead><tbody>';
        
        for (const row of dataRows) {
          const cells = parseTableRow(row);
          tableHtml += '<tr>';
          for (let i = 0; i < headerCells.length; i++) {
            const cellContent = cells[i] !== undefined ? cells[i].trim() : '';
            tableHtml += `<td>${inline(cellContent, baseUrl)}</td>`;
          }
          tableHtml += '</tr>';
        }
        
        tableHtml += '</tbody></table>';
        html += tableHtml;
        
        tableBuffer = [];
        inTable = false;
      }

      function parseTableRow(row) {
        // Remove leading/trailing pipes and split by pipe
        let trimmed = row.trim();
        if (trimmed.startsWith('|')) trimmed = trimmed.slice(1);
        if (trimmed.endsWith('|')) trimmed = trimmed.slice(0, -1);
        return trimmed.split('|');
      }

      function isTableSeparator(line) {
        // Matches |---|---|---| or |:---|:---:|---:|
        return /^\|?(\s*:?-+:?\s*\|)+\s*:?-+:?\s*\|?$/.test(line.trim());
      }

      function isTableRow(line) {
        const trimmed = line.trim();
        return trimmed.startsWith('|') && trimmed.endsWith('|') && trimmed.includes('|');
      }

      function inline(text, baseUrlLocal) {
        let t = escapeHtml(text);
        t = t.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, (m, alt, url) => {
          const safeAlt = escapeHtml(alt);
          const resolved = resolveUrl(url, baseUrlLocal);
          return `<img src="${resolved}" alt="${safeAlt}" />`;
        });
        t = t.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (m, label, url) => {
          const resolved = resolveUrl(url, baseUrlLocal);
          return `<a href="${resolved}">${label}</a>`;
        });
        t = t.replace(/`([^`]+)`/g, '<code>$1</code>');
        t = t.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
        t = t.replace(/\*([^*]+)\*/g, '<em>$1</em>');
        return t;
      }

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const trimmed = line.trim();
        
        // Code blocks
        if (trimmed.startsWith('```')) {
          if (!inCode) {
            flushParagraph();
            flushList();
            flushTable();
            inCode = true;
            codeLang = trimmed.replace('```', '').trim();
          } else {
            inCode = false;
            flushCode();
          }
          continue;
        }
        if (inCode) {
          codeBuffer.push(line);
          continue;
        }
        
        // Table detection
        if (isTableRow(trimmed)) {
          if (!inTable) {
            // Check if next line is separator
            const nextLine = lines[i + 1];
            if (nextLine && isTableSeparator(nextLine)) {
              flushParagraph();
              flushList();
              inTable = true;
              tableBuffer.push(trimmed);
              continue;
            }
          }
          if (inTable) {
            tableBuffer.push(trimmed);
            continue;
          }
        }
        
        // Table separator (only when in table)
        if (inTable && isTableSeparator(trimmed)) {
          tableBuffer.push(trimmed);
          continue;
        }
        
        // End of table (non-table line while in table)
        if (inTable && !isTableRow(trimmed) && !isTableSeparator(trimmed)) {
          flushTable();
        }
        
        // Headings
        if (/^#{1,6}\s/.test(trimmed)) {
          flushParagraph();
          flushList();
          flushTable();
          const level = trimmed.match(/^#+/)[0].length;
          const text = trimmed.replace(/^#{1,6}\s+/, '').trim();
          const id = slugify(text);
          headings.push({ level, text, id });
          html += `<h${level} id="${id}">${inline(text, baseUrl)}</h${level}>`;
          continue;
        }
        
        // List items
        if (/^[-*]\s+/.test(trimmed)) {
          flushParagraph();
          flushTable();
          listBuffer.push(trimmed.replace(/^[-*]\s+/, ''));
          continue;
        }
        
        // Empty line
        if (trimmed === '') {
          flushParagraph();
          flushList();
          if (inTable) flushTable();
          continue;
        }
        
        // Regular paragraph text
        paraBuffer.push(trimmed);
      }
      
      flushParagraph();
      flushList();
      flushCode();
      flushTable();

      return { html, headings };
    }

    async function loadDoc() {
      if (!docParam) {
        contentEl.textContent = 'No document specified.';
        return;
      }
      try {
        const docUrl = new URL(docParam, window.location.href);
        const res = await fetch(docUrl);
        if (!res.ok) throw new Error('Failed to load document');
        const md = await res.text();
        const { html, headings } = renderMarkdown(md, docUrl.href);
        contentEl.innerHTML = html;
        titleEl.textContent = docParam.split('/').pop();
        metaEl.textContent = docParam;
        tocListEl.innerHTML = headings.map(h => {
          const indent = (h.level - 1) * 12;
          return `<div style="margin-left:${indent}px"><a href="#${h.id}">${h.text}</a></div>`;
        }).join('');
        linksEl.innerHTML = `
          <a href="${docUrl.href}">Raw .md</a>
          <a href="index.html">Index</a>
        `;
      } catch (err) {
        contentEl.textContent = 'Unable to load document: ' + err.message;
      }
    }

    loadDoc();
  </script>
</body>
</html>
